diff --git a/src/http/modules/ngx_http_image_filter_module.c b/src/http/modules/ngx_http_image_filter_module.c
index dbec5d8..7b1ede5 100644
--- a/src/http/modules/ngx_http_image_filter_module.c
+++ b/src/http/modules/ngx_http_image_filter_module.c
@@ -18,6 +18,7 @@
 #define NGX_HTTP_IMAGE_RESIZE    3
 #define NGX_HTTP_IMAGE_CROP      4
 #define NGX_HTTP_IMAGE_ROTATE    5
+#define NGX_HTTP_IMAGE_WATERMARK 6
 
 
 #define NGX_HTTP_IMAGE_START     0
@@ -48,6 +49,9 @@ typedef struct {
 
     ngx_flag_t                   transparency;
     ngx_flag_t                   interlace;
+    ngx_flag_t                   upscale;
+    ngx_str_t                    watermark;
+    ngx_str_t                    watermark_position;
 
     ngx_http_complex_value_t    *wcv;
     ngx_http_complex_value_t    *hcv;
@@ -163,6 +167,13 @@ static ngx_command_t  ngx_http_image_filter_commands[] = {
       offsetof(ngx_http_image_filter_conf_t, interlace),
       NULL },
 
+    { ngx_string("image_filter_upscale"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
+      ngx_conf_set_flag_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_image_filter_conf_t, upscale),
+      NULL },
+
     { ngx_string("image_filter_buffer"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_size_slot,
@@ -170,6 +181,20 @@ static ngx_command_t  ngx_http_image_filter_commands[] = {
       offsetof(ngx_http_image_filter_conf_t, buffer_size),
       NULL },
 
+    { ngx_string("image_filter_watermark"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_image_filter_conf_t, watermark),
+      NULL },
+
+    { ngx_string("image_filter_watermark_position"),
+      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_image_filter_conf_t, watermark_position),
+      NULL },
+
       ngx_null_command
 };
 
@@ -551,6 +576,15 @@ ngx_http_image_process(ngx_http_request_t *r)
         return ngx_http_image_resize(r, ctx);
     }
 
+    if (conf->filter == NGX_HTTP_IMAGE_WATERMARK) {
+
+        if (!conf->watermark.data) {
+            return NULL;
+        }
+
+        return ngx_http_image_resize(r, ctx);
+    }
+
     ctx->max_width = ngx_http_image_filter_get_value(r, conf->wcv, conf->width);
     if (ctx->max_width == 0) {
         return NULL;
@@ -563,8 +597,9 @@ ngx_http_image_process(ngx_http_request_t *r)
     }
 
     if (rc == NGX_OK
-        && ctx->width <= ctx->max_width
-        && ctx->height <= ctx->max_height
+        && (ctx->width <= ctx->max_width
+            && ctx->height <= ctx->max_height
+            && !conf->upscale)
         && ctx->angle == 0
         && !ctx->force)
     {
@@ -842,8 +877,9 @@ ngx_http_image_resize(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
 
     if (!ctx->force
         && ctx->angle == 0
-        && (ngx_uint_t) sx <= ctx->max_width
-        && (ngx_uint_t) sy <= ctx->max_height)
+        && ((ngx_uint_t) sx <= ctx->max_width
+            && (ngx_uint_t) sy <= ctx->max_height
+            && !conf->upscale))
     {
         gdImageDestroy(src);
         return ngx_http_image_asis(r, ctx);
@@ -879,7 +915,7 @@ transparent:
 
     if (conf->filter == NGX_HTTP_IMAGE_RESIZE) {
 
-        if ((ngx_uint_t) dx > ctx->max_width) {
+        if ((ngx_uint_t) dx > ctx->max_width || conf->upscale) {
             dy = dy * ctx->max_width / dx;
             dy = dy ? dy : 1;
             dx = ctx->max_width;
@@ -897,12 +933,16 @@ transparent:
 
         resize = 0;
 
+    } else if (conf->filter == NGX_HTTP_IMAGE_WATERMARK) {
+
+        resize = 0;
+
     } else { /* NGX_HTTP_IMAGE_CROP */
 
         resize = 0;
 
         if ((double) dx / dy < (double) ctx->max_width / ctx->max_height) {
-            if ((ngx_uint_t) dx > ctx->max_width) {
+            if ((ngx_uint_t) dx > ctx->max_width || conf->upscale) {
                 dy = dy * ctx->max_width / dx;
                 dy = dy ? dy : 1;
                 dx = ctx->max_width;
@@ -910,7 +950,7 @@ transparent:
             }
 
         } else {
-            if ((ngx_uint_t) dy > ctx->max_height) {
+            if ((ngx_uint_t) dy > ctx->max_height || conf->upscale) {
                 dx = dx * ctx->max_height / dy;
                 dx = dx ? dx : 1;
                 dy = ctx->max_height;
@@ -1042,6 +1082,49 @@ transparent:
         gdImageColorTransparent(dst, gdImageColorExact(dst, red, green, blue));
     }
 
+    if (conf->filter == NGX_HTTP_IMAGE_WATERMARK && conf->watermark.data) {
+        FILE *watermark_file = fopen((const char *)conf->watermark.data, "r");
+
+        if (watermark_file) {
+            gdImagePtr watermark, watermark_mix;
+            ngx_int_t wdx = 0, wdy = 0;
+
+            watermark = gdImageCreateFromPng(watermark_file);
+            fclose(watermark_file);
+
+            if(watermark != NULL) {
+                watermark_mix = gdImageCreateTrueColor(watermark->sx, watermark->sy);
+
+                if (ngx_strcmp(conf->watermark_position.data, "bottom-right") == 0) {
+                    wdx = dx - watermark->sx - 10;
+                    wdy = dy - watermark->sy - 10;
+                } else if (ngx_strcmp(conf->watermark_position.data, "top-left") == 0) {
+                    wdx = wdy = 10;
+                } else if (ngx_strcmp(conf->watermark_position.data, "top-right") == 0) {
+                    wdx = dx - watermark->sx - 10;
+                    wdy = 10;
+                } else if (ngx_strcmp(conf->watermark_position.data, "bottom-left") == 0) {
+                    wdx = 10;
+                    wdy = dy - watermark->sy - 10;
+                } else if (ngx_strcmp(conf->watermark_position.data, "center") == 0) {
+                    wdx = dx / 2 - watermark->sx / 2;
+                    wdy = dy / 2 - watermark->sy / 2;
+                }
+
+                gdImageCopy(watermark_mix, dst, 0, 0, wdx, wdy, watermark->sx, watermark->sy);
+                gdImageCopy(watermark_mix, watermark, 0, 0, 0, 0, watermark->sx, watermark->sy);
+                gdImageCopyMerge(dst, watermark_mix, wdx, wdy, 0, 0, watermark->sx, watermark->sy, 75);
+                gdImageDestroy(watermark);
+                gdImageDestroy(watermark_mix);
+
+            } else { ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "watermark file '%s' is not PNG", conf->watermark.data);}
+
+        } else {
+
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0, "watermark file '%s' not found", conf->watermark.data);
+        }
+    }
+
     sharpen = ngx_http_image_filter_get_value(r, conf->shcv, conf->sharpen);
     if (sharpen > 0) {
         gdImageSharpen(dst, sharpen);
@@ -1301,6 +1384,7 @@ ngx_http_image_filter_create_conf(ngx_conf_t *cf)
     conf->sharpen = NGX_CONF_UNSET_UINT;
     conf->transparency = NGX_CONF_UNSET;
     conf->interlace = NGX_CONF_UNSET;
+    conf->upscale = NGX_CONF_UNSET;
     conf->buffer_size = NGX_CONF_UNSET_SIZE;
 
     return conf;
@@ -1361,9 +1445,15 @@ ngx_http_image_filter_merge_conf(ngx_conf_t *cf, void *parent, void *child)
 
     ngx_conf_merge_value(conf->interlace, prev->interlace, 0);
 
+    ngx_conf_merge_value(conf->upscale, prev->upscale, 0);
+
     ngx_conf_merge_size_value(conf->buffer_size, prev->buffer_size,
                               1 * 1024 * 1024);
 
+    ngx_conf_merge_str_value(conf->watermark, prev->watermark, "");
+
+    ngx_conf_merge_str_value(conf->watermark_position, prev->watermark_position, "bottom-right");
+
     return NGX_CONF_OK;
 }
 
@@ -1439,11 +1529,23 @@ ngx_http_image_filter(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
 
             return NGX_CONF_OK;
 
+        } else if (ngx_strcmp(value[i].data, "watermark") == 0) {
+            imcf->filter = NGX_HTTP_IMAGE_WATERMARK;
+            imcf->watermark = value[2];
+            return NGX_CONF_OK;
+
         } else {
             goto failed;
         }
     }
 
+    if ((ngx_strcmp(value[i].data, "watermark") == 0) && cf->args->nelts == 4) {
+        imcf->filter = NGX_HTTP_IMAGE_WATERMARK;
+        imcf->watermark = value[2];
+        imcf->watermark_position = value[3];
+        return NGX_CONF_OK;
+    }
+
     if (ngx_strcmp(value[i].data, "resize") == 0) {
         imcf->filter = NGX_HTTP_IMAGE_RESIZE;
 
